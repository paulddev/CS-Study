# Set 컨테이너
`#include <set>` 헤더파일

## set 특징
- Associative 컨테이너 (Key로서 접근에 의미를 가지는 연관 컨테이너)
- 원소는 중복 저장될 수 없다. (유니크하다)
  * 같은 원소로 이미 들어있다면 나중에 오는 `insert`는 무시된다.
  * 중복 검사를 해야 한다면 `set` 컨테이너에 넣으면 중복 검사를 할 필요 없이 `insert`해주면 된다.
- 자동으로 원소들이 순서대로 `정렬`되어 들어간다.

## map과 다른점
- map은 (key, value) 연결된다.
  * m["사과"] = 2000
  * map의 원소는 `std::pair`
- set은 Key
  * 해당 Key 데이터가 set에 존재하는지 체크
  * 집합

## 메소드들
- `begin()` : 시작 반복자 리턴
- `end()` : 끝 반복자 리턴
- `insert(key)` : 중복 원소는 허락하지 않으므로 기존에 key가 이미 있다면 무시된다.
- `erase(key)` : key에 해당하는 원소를 삭제한다.
- `clear()` : set의 모든 원소를 삭제한다.
- `find(key)` : 원소 값에 해당하는 반복자를 리턴한다. 만약에 없다면 end() 리턴
- `empty()` : 비어있으면 true, 아니면 false
- `size()` : set에 저장된 총 개수 리턴

## multiset
`set`과 다르게 중복 원소를 허용한다.

insert 연산에서 중복 Key가 있어도 해당 원소를 넣어준다.

## unordered_set
사용법은 `set`과 동일하다.

set과 다르게 정렬되지 않으며 해시 함수를 사용하여 원소를 탐색한다.

## set vs unordered_set
`set` : 정렬되어 있는 상태에서 탐색을 하므로 `O(logN)` 평균, 최악의 경우도 모두 같다.
`unordered_set` : 해시 함수로 탐색을 하므로 평균  `O(1)` 매우 빠르지만, 해시 충돌이 빈번하게 발생하는 경우 최악의 경우 `O(N)`으로 set보다 더 오래 걸릴 수 있다.

원소의 개수가 많을수록 해시충돌 또한 일어날 확률이 높아지기 때문에 2가지 선택을 할 수 있다.
- 원소의 개수가 적고 빠른 성능을 원할 땐 `unordered_set`
- 원소의 개수가 많고 안정적 성능을 원할 땐 `set`
