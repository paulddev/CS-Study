# 알고리즘 성능분석
잘 동작하는 것은 물론 좋은 성능까지 보장받기 위해서는 성능분석을 할 줄 알아야 한다. <br>
=> 자료구조와 알고리즘을 분석하고 평가

`만능 키와 같은 자료구조와 알고리즘은 존재하지 않기 때문이다`
- 어떤 알고리즘이 어떠한 상황에서 더 빠르고 또 느린지?
- 어떤 알고리즘이 어떠한 상황에서 메모리를 적게 쓰고 또 많이 쓰는지?

대게 평가할 때는 `메모리의 사용량`보다는 `실행속도`에 초점을 맞춘다. `속도`에 관심을 더 많이 가지고, 최근에는 메모리의 사용량은 세상이 좋아지기 때문이다. <br>
빅 데이터의 경우 많은 양의 데이터 중 실속있는 정보들만 추려낼 때도 `속도`가 중요하다.

## 수행속도를 평가하는 방법
- 연산의 횟수를 카운팅
- 처리해야 할 데이터의 수 N에 대해서 연산횟수의 함수 T(n)을 구성한다.

식을 구성하면 데이터 수의 증가에 따른 연산횟수의 변화 정도를 판단할 수 있다.

## 빅-오 표기법(Big-Oh Notation)
- T(n)에서 가장 영향력이 큰 부분이 어딘가를 따지는 것
- 알고리즘의 효율성을 나타내는 지표 혹은 언어

`빅-오` : 시간의 상한 <br>
`빅-오메가` : 시간의 하한 <br>
`빅-세타` : 빅오와 빅오메가를 하나로 합쳐 표현하는 것과 같다.

```cpp
T(n) = 2n^2 + 2n + 1 =>  O(N^2)
N^2이 차지하는 비율이 절대적이기 때문이다.
```

## 시간 복잡도(Time Complexity)
- 점근적 실행 시간(asymptotic runtime), 빅-오 시간에 대한 개념이다.
- 가능한 실행 시간이 딱 정해져 있는 것이 아니다.
- 최선(best), 최악(worst), 평균(average) 로 나타내서 표기한다.

## 공간 복잡도(Space Complexity)
- 시간뿐만 아니라 메모리(혹은 공간) 또한 신경써야 한다.
- 

## 대표적인 빅-오
`O(1)`
- 상수시간
- 데이터 수에 상관없이 연산횟수가 고정인 유형의 알고리즘을 뜻한다.
- 간단한 연산의 경우를 표시함

`O(logN)`
- 로그형
- 데이터 수의 증가율에 비해서 연산횟수의 증가율이 훨씬 낮은 알고리즘
- 바람직한 유형
- 보통 탐색할 때마다 반으로 쪼개진다거나, 10으로 나뉘는 경우 로그라고 할 수 있다.
- `이진탐색`으로 탐색할 때

`O(n)`
- 대표적인 선형 시간
- 데이터의 수와 연산횟수가 비례하는 알고리즘에서 많이 사용한다.
- `선형탐색`으로 탐색할 때

`O(NlogN)`
- 선형로그형
- 데이터의 수가 두 배로 늘어날 때, 연산횟수는 두 배를 조금 넘게 증가하는 알고리즘
- 보통 정렬 알고리즘의 시간복잡도에서 보인다.

`O(N^2)`
- 데이터 수의 제곱에 해당하는 연산횟수를 요구하는 알고리즘
- 데이터의 양이 많은 경우에는 적용하기가 부적절하다.
- 보통 반복문을 중첩으로 사용했을 때 보인다.

`O(N^3)`
- 데이터 수의 세 제곱에 해당하는 연산횟수를 요구하는 알고리즘
- 삼중으로 중첩된 반복문 내에서 알고리즘에 관련된 연산이 진행되는 경우에 발생한다.
- 그냥 적용하기에는 무리가 있는 수준
- `플로이드 워샬` 알고리즘 시간복잡도

`O(2^n)`
- 지수형
- 그냥 사용하기에는 매우 무리가 있는 알고리즘
- 매우 무서운 연산횟수의 증가를 보인다.

## 상수항은 무시하자.
빅-오는 단순히 증가하는 비율을 나타내는 개념이다.

## 지배적이지 않은 항은 무시하자.
O(n^2 + n) => O(n^2)

주의할 점은 O(B^2 + A)는 O(B^2)으로 줄일 수 없다.

















